{
    "summary": "The code establishes Minecraft agent settings for a reinforcement learning project, including environment configuration and an agent class with action mapping, transforming, policy-making capabilities, and device support for actions.",
    "details": [
        {
            "comment": "The code imports necessary libraries and defines various settings for a Minecraft agent. It includes hardcoded resolution, policy arguments, action transformer arguments, and other configuration options. The code seems to be part of a larger project involving reinforcement learning and a specific environment (Minecraft in this case).",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":0-39",
            "content": "import numpy as np\nimport torch as th\nimport cv2\nfrom gym3.types import DictType\nfrom gym import spaces\nfrom lib.action_mapping import CameraHierarchicalMapping\nfrom lib.actions import ActionTransformer\nfrom lib.policy import MinecraftAgentPolicy\nfrom lib.torch_util import default_device_type, set_default_torch_device\n# Hardcoded settings\nAGENT_RESOLUTION = (128, 128)\nPOLICY_KWARGS = dict(\n    attention_heads=16,\n    attention_mask_style=\"clipped_causal\",\n    attention_memory_size=256,\n    diff_mlp_embedding=False,\n    hidsize=2048,\n    img_shape=[128, 128, 3],\n    impala_chans=[16, 32, 32],\n    impala_kwargs={\"post_pool_groups\": 1},\n    impala_width=8,\n    init_norm_kwargs={\"batch_norm\": False, \"group_norm_groups\": 1},\n    n_recurrence_layers=4,\n    only_img_input=True,\n    pointwise_ratio=4,\n    pointwise_use_activation=False,\n    recurrence_is_residual=True,\n    recurrence_type=\"transformer\",\n    timesteps=128,\n    use_pointwise_layer=True,\n    use_pre_lstm_ln=False,\n)\nPI_HEAD_KWARGS = dict(temperature=2.0)\nACTION_TRANSFORMER_KWARGS = dict("
        },
        {
            "comment": "This code sets various parameters for a game agent. It defines action space, environment keywords, and camera settings for the game environment. The action space includes actions like ESC, attack, back, camera adjustment, dropping items, moving, using hotbar slots, inventory management, jumping, moving left/right, and sneaking. Environment keywords specify fields such as field of view (fov_range), frameskip, gamma value range, gui scale range, game resolution, and cursor size range. Camera settings include bin size, maximum value, mean value, and quantization scheme for the camera input.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":40-76",
            "content": "    camera_binsize=2,\n    camera_maxval=10,\n    camera_mu=10,\n    camera_quantization_scheme=\"mu_law\",\n)\nENV_KWARGS = dict(\n    fov_range=[70, 70],\n    frameskip=1,\n    gamma_range=[2, 2],\n    guiscale_range=[1, 1],\n    resolution=[640, 360],\n    cursor_size_range=[16.0, 16.0],\n)\nTARGET_ACTION_SPACE = {\n    \"ESC\": spaces.Discrete(2),\n    \"attack\": spaces.Discrete(2),\n    \"back\": spaces.Discrete(2),\n    \"camera\": spaces.Box(low=-180.0, high=180.0, shape=(2,)),\n    \"drop\": spaces.Discrete(2),\n    \"forward\": spaces.Discrete(2),\n    \"hotbar.1\": spaces.Discrete(2),\n    \"hotbar.2\": spaces.Discrete(2),\n    \"hotbar.3\": spaces.Discrete(2),\n    \"hotbar.4\": spaces.Discrete(2),\n    \"hotbar.5\": spaces.Discrete(2),\n    \"hotbar.6\": spaces.Discrete(2),\n    \"hotbar.7\": spaces.Discrete(2),\n    \"hotbar.8\": spaces.Discrete(2),\n    \"hotbar.9\": spaces.Discrete(2),\n    \"inventory\": spaces.Discrete(2),\n    \"jump\": spaces.Discrete(2),\n    \"left\": spaces.Discrete(2),\n    \"pickItem\": spaces.Discrete(2),\n    \"right\": spaces.Discrete(2),\n    \"sneak\": spaces.Discrete(2),"
        },
        {
            "comment": "This code defines a dictionary ENV_KWARGS that contains expected environment settings for the MineRL environment. It also includes a function validate_env() to check if the environment is set up correctly and raise an error if any setting does not match the expected value. Additionally, it checks if the action space of the MineRL environment matches the expected actions and their respective spaces. The code also provides a comment suggesting to resize images using INTER_LINEAR resizing function for better results.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":77-100",
            "content": "    \"sprint\": spaces.Discrete(2),\n    \"swapHands\": spaces.Discrete(2),\n    \"use\": spaces.Discrete(2)\n}\ndef validate_env(env):\n    \"\"\"Check that the MineRL environment is setup correctly, and raise if not\"\"\"\n    for key, value in ENV_KWARGS.items():\n        if key == \"frameskip\":\n            continue\n        if getattr(env.task, key) != value:\n            raise ValueError(f\"MineRL environment setting {key} does not match {value}\")\n    action_names = set(env.action_space.spaces.keys())\n    if action_names != set(TARGET_ACTION_SPACE.keys()):\n        raise ValueError(f\"MineRL action space does match. Expected actions {set(TARGET_ACTION_SPACE.keys())}\")\n    for ac_space_name, ac_space_space in TARGET_ACTION_SPACE.items():\n        if env.action_space.spaces[ac_space_name] != ac_space_space:\n            raise ValueError(f\"MineRL action space setting {ac_space_name} does not match {ac_space_space}\")\ndef resize_image(img, target_resolution):\n    # For your sanity, do not resize with any function than INTER_LINEAR"
        },
        {
            "comment": "This code defines a MineRLAgent class with an __init__ method. It resizes the image using cv2.resize and returns it. The class has attributes for action_mapper, action_transformer, policy, and device. The policy is created with given policy_kwargs, pi_head_kwargs, and action_space. The device is set as the default torch device.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":101-127",
            "content": "    img = cv2.resize(img, target_resolution, interpolation=cv2.INTER_LINEAR)\n    return img\nclass MineRLAgent:\n    def __init__(self, env, device=None, policy_kwargs=None, pi_head_kwargs=None):\n        validate_env(env)\n        if device is None:\n            device = default_device_type()\n        self.device = th.device(device)\n        # Set the default torch device for underlying code as well\n        set_default_torch_device(self.device)\n        self.action_mapper = CameraHierarchicalMapping(n_camera_bins=11)\n        action_space = self.action_mapper.get_action_space_update()\n        action_space = DictType(**action_space)\n        self.action_transformer = ActionTransformer(**ACTION_TRANSFORMER_KWARGS)\n        if policy_kwargs is None:\n            policy_kwargs = POLICY_KWARGS\n        if pi_head_kwargs is None:\n            pi_head_kwargs = PI_HEAD_KWARGS\n        agent_kwargs = dict(policy_kwargs=policy_kwargs, pi_head_kwargs=pi_head_kwargs, action_space=action_space)\n        self.policy = MinecraftAgentPolicy(**agent_kwargs).to(device)"
        },
        {
            "comment": "The code defines a class for an agent with methods to reset its hidden state, convert MineRL observations into the model's observation format, and convert policy output into actions for the MineRL environment. It also includes a method to load model weights from a given path while resetting the hidden state.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":128-153",
            "content": "        self.hidden_state = self.policy.initial_state(1)\n        self._dummy_first = th.from_numpy(np.array((False,))).to(device)\n    def load_weights(self, path):\n        \"\"\"Load model weights from a path, and reset hidden state\"\"\"\n        self.policy.load_state_dict(th.load(path, map_location=self.device), strict=False)\n        self.reset()\n    def reset(self):\n        \"\"\"Reset agent to initial state (i.e., reset hidden state)\"\"\"\n        self.hidden_state = self.policy.initial_state(1)\n    def _env_obs_to_agent(self, minerl_obs):\n        \"\"\"\n        Turn observation from MineRL environment into model's observation\n        Returns torch tensors.\n        \"\"\"\n        agent_input = resize_image(minerl_obs[\"pov\"], AGENT_RESOLUTION)[None]\n        agent_input = {\"img\": th.from_numpy(agent_input).to(self.device)}\n        return agent_input\n    def _agent_action_to_env(self, agent_action):\n        \"\"\"Turn output from policy into action for MineRL\"\"\"\n        # This is quite important step (for some reason).\n        # For the sake of your sanity, remember to do this step (manual conversion to numpy)"
        },
        {
            "comment": "This code snippet is part of a function that transforms actions from MineRL format to the model's action format and vice versa. It also handles the conversion between PyTorch tensors and numpy arrays, and checks if the action is null (no action).",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":154-174",
            "content": "        # before proceeding. Otherwise, your agent might be a little derp.\n        action = agent_action\n        if isinstance(action[\"buttons\"], th.Tensor):\n            action = {\n                \"buttons\": agent_action[\"buttons\"].cpu().numpy(),\n                \"camera\": agent_action[\"camera\"].cpu().numpy()\n            }\n        minerl_action = self.action_mapper.to_factored(action)\n        minerl_action_transformed = self.action_transformer.policy2env(minerl_action)\n        return minerl_action_transformed\n    def _env_action_to_agent(self, minerl_action_transformed, to_torch=False, check_if_null=False):\n        \"\"\"\n        Turn action from MineRL to model's action.\n        Note that this will add batch dimensions to the action.\n        Returns numpy arrays, unless `to_torch` is True, in which case it returns torch tensors.\n        If `check_if_null` is True, check if the action is null (no action) after the initial\n        transformation. This matches the behaviour done in OpenAI's VPT work.\n        If action is null, return \"None\" instead"
        },
        {
            "comment": "This code defines a class that takes MineRL observations as input and outputs the corresponding action. It includes methods for transforming actions, mapping actions, and getting an agent's action for a given observation. The action is returned with batch dimensions if necessary, and can be converted to PyTorch tensors if needed.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":175-198",
            "content": "        \"\"\"\n        minerl_action = self.action_transformer.env2policy(minerl_action_transformed)\n        if check_if_null:\n            if np.all(minerl_action[\"buttons\"] == 0) and np.all(minerl_action[\"camera\"] == self.action_transformer.camera_zero_bin):\n                return None\n        # Add batch dims if not existant\n        if minerl_action[\"camera\"].ndim == 1:\n            minerl_action = {k: v[None] for k, v in minerl_action.items()}\n        action = self.action_mapper.from_factored(minerl_action)\n        if to_torch:\n            action = {k: th.from_numpy(v).to(self.device) for k, v in action.items()}\n        return action\n    def get_action(self, minerl_obs):\n        \"\"\"\n        Get agent's action for given MineRL observation.\n        Agent's hidden state is tracked internally. To reset it,\n        call `reset()`.\n        \"\"\"\n        agent_input = self._env_obs_to_agent(minerl_obs)\n        # The \"first\" argument could be used to reset tell episode\n        # boundaries, but we are only using this for predicting (for now),"
        },
        {
            "comment": "This code selects an action from the agent's policy and returns it after converting to environment format.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/agent.py\":199-205",
            "content": "        # so we do not hassle with it yet.\n        agent_action, self.hidden_state, _ = self.policy.act(\n            agent_input, self._dummy_first, self.hidden_state,\n            stochastic=True\n        )\n        minerl_action = self._agent_action_to_env(agent_action)\n        return minerl_action"
        }
    ]
}