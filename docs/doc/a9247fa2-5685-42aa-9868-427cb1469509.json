{
    "summary": "The code includes utility functions for manipulating data structures, defines partial applications and safe mapping functions for multiple lists, and registers different data types and their conversion functions for serialization using the PyTree API.",
    "details": [
        {
            "comment": "This code block contains utility functions for manipulating dictionaries, tuples and lists. It defines two functions: unzip2 and partial. Unzip2 takes a list of pairs (x, y) and returns the corresponding x and y as separate tuples. Partial is a wrapper function that creates a partial application of another function with specified arguments or keyword arguments.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":0-34",
            "content": "# Copyright 2018 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# Copied this from jax, made it self-contained\n# Currently just used for improved_checkpoint\nimport collections\nimport functools\nimport itertools as it\nfrom collections.abc import Collection\nfrom typing import Dict, List, Optional\ndef unzip2(xys):\n    xs = []\n    ys = []\n    for x, y in xys:\n        xs.append(x)\n        ys.append(y)\n    return tuple(xs), tuple(ys)\ndef partial(fun, *args, **kwargs):\n    wrapped = functools.partial(fun, *args, **kwargs)"
        },
        {
            "comment": "This code contains three functions:\n1. `safe_zip()` - creates a list of tuples from multiple lists, asserting that all lists have the same length.\n2. `safe_map()` - applies a function to each element in a list (or multiple lists), asserting that all lists have the same length.\n3. `tree_map()` - maps a function over a pytree and returns a new pytree with the same structure, but with values at leaves given by applying the function to corresponding leaf values in the original tree.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":35-69",
            "content": "    functools.update_wrapper(wrapped, fun)\n    wrapped._bound_args = args  # pylint: disable=protected-access\n    return wrapped\ndef safe_zip(*args: Collection) -> List[tuple]:\n    n = len(args[0])\n    for arg in args[1:]:\n        assert len(arg) == n, \"length mismatch: {}\".format(list(map(len, args)))\n    return list(zip(*args))\ndef safe_map(f, *args):\n    args = list(map(list, args))\n    n = len(args[0])\n    for arg in args[1:]:\n        assert len(arg) == n, \"length mismatch: {}\".format(list(map(len, args)))\n    return list(map(f, *args))\ndef tree_map(f, tree, treat_as_leaves: Optional[List] = None):\n    \"\"\"Map a function over a pytree to produce a new pytree.\n    Args:\n      f: function to be applied at each leaf.\n      tree: a pytree to be mapped over.\n    Returns:\n      A new pytree with the same structure as `tree` but with the value at each\n      leaf given by `f(x)` where `x` is the value at the corresponding leaf in\n      `tree`.\n    \"\"\"\n    if treat_as_leaves is None:\n        treat_as_leaves = []\n    node_type = node_types.get(type(tree))"
        },
        {
            "comment": "This function applies a multi-input function to the leaves of a pytree and its sibling pytrees, returning a new pytree with values determined by `f(x, *xs)` where `x` is the value at the corresponding leaf in the original tree and `xs` is the tuple of values at corresponding leaves in the sibling trees. If the node type allows for further processing, it iterates over the children and applies the function to each child and its corresponding siblings before returning a new pytree.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":70-92",
            "content": "    if node_type and type(tree) not in treat_as_leaves:\n        children, node_spec = node_type.to_iterable(tree)\n        new_children = [tree_map(f, child, treat_as_leaves) for child in children]\n        return node_type.from_iterable(node_spec, new_children)\n    else:\n        return f(tree)\ndef tree_multimap(f, tree, *rest, treat_as_leaves: Optional[List] = None):\n    \"\"\"Map a multi-input function over pytree args to produce a new pytree.\n    Args:\n      f: function that takes `1 + len(rest)` arguments, to be applied at the\n        corresponding leaves of the pytrees.\n      tree: a pytree to be mapped over, with each leaf providing the first\n        positional argument to `f`.\n      *rest: a tuple of pytrees, each with the same structure as `tree`.\n    Returns:\n      A new pytree with the same structure as `tree` but with the value at each\n      leaf given by `f(x, *xs)` where `x` is the value at the corresponding leaf\n      in `tree` and `xs` is the tuple of values at corresponding leaves in `rest`.\n    \"\"\""
        },
        {
            "comment": "This code is determining the appropriate node type for a given tree and iterating through trees to ensure they match. It then applies a function f to each tree, handling different cases based on whether the node type is specified or not.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":94-118",
            "content": "    if treat_as_leaves is None:\n        treat_as_leaves = []\n    node_type = node_types.get(type(tree))\n    if node_type and type(tree) not in treat_as_leaves:\n        children, node_spec = node_type.to_iterable(tree)\n        all_children = [children]\n        for other_tree in rest:\n            other_children, other_node_data = node_type.to_iterable(other_tree)\n            if other_node_data != node_spec:\n                raise TypeError(\"Mismatch: {} != {}\".format(other_node_data, node_spec))\n            all_children.append(other_children)\n        new_children = [tree_multimap(f, *xs, treat_as_leaves=treat_as_leaves) for xs in zip(*all_children)]\n        return node_type.from_iterable(node_spec, new_children)\n    else:\n        return f(tree, *rest)\ndef prefix_multimap(f, treedef, tree, *rest):\n    \"\"\"Like tree_multimap but only maps down through a tree prefix.\"\"\"\n    if isinstance(treedef, PyLeaf):\n        return f(tree, *rest)\n    else:\n        node_type = node_types.get(type(tree))\n        if node_type != treedef.node_type:"
        },
        {
            "comment": "Code is iterating over a tree structure and checking if the nodes match in terms of node type, node data, and number of children. If any mismatches are found, a TypeError is raised. The function walks through the tree recursively and applies functions to both leaf and non-leaf nodes based on their types. Optional treat_as_leaves list specifies which types should be treated as leaves.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":119-140",
            "content": "            raise TypeError(\"Mismatch: {} != {}\".format(treedef.node_type, node_type))\n        children, node_data = node_type.to_iterable(tree)\n        if node_data != treedef.node_data:\n            raise TypeError(\"Mismatch: {} != {}\".format(treedef.node_data, node_data))\n        all_children = [children]\n        for other_tree in rest:\n            other_children, other_node_data = node_type.to_iterable(other_tree)\n            if other_node_data != node_data:\n                raise TypeError(\"Mismatch: {} != {}\".format(other_node_data, node_data))\n            all_children.append(other_children)\n        all_children = zip(*all_children)\n        new_children = [prefix_multimap(f, td, *xs) for td, xs in zip(treedef.children, all_children)]\n        return node_type.from_iterable(node_data, new_children)\ndef walk_pytree(f_node, f_leaf, tree, treat_as_leaves: Optional[List] = None):\n    node_type = node_types.get(type(tree))\n    if treat_as_leaves is None:\n        treat_as_leaves = []\n    if node_type and type(tree) not in treat_as_leaves:"
        },
        {
            "comment": "Function `to_iterable` splits node type and specifications, walks tree using function `walk_pytree`, unzips the result into procedure children and child specifications, creates a `PyTreeDef` object, and returns the processed children and tree definition.\n`build_tree` recursively builds the tree by calling itself on each child of the current node and constructs the final node using the node type and data.\n`_tree_unflatten` recursively unflattens the tree by calling itself on each child of the current node.\nFunction `_num_leaves` returns 1 if the treedef is a leaf, otherwise it sums the number of leaves in each child.\nFunction `_nested_treedef` takes two node types and returns a nested tree definition.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":141-170",
            "content": "        children, node_spec = node_type.to_iterable(tree)\n        proc_children, child_specs = unzip2([walk_pytree(f_node, f_leaf, child, treat_as_leaves) for child in children])\n        tree_def = PyTreeDef(node_type, node_spec, child_specs)\n        return f_node(proc_children), tree_def\n    else:\n        return f_leaf(tree), PyLeaf()\ndef build_tree(treedef, xs):\n    if isinstance(treedef, PyLeaf):\n        return xs\n    else:\n        # We use 'iter' for clearer error messages\n        children = safe_map(build_tree, iter(treedef.children), iter(xs))\n        return treedef.node_type.from_iterable(treedef.node_data, children)\ndef _tree_unflatten(xs, treedef):\n    if isinstance(treedef, PyLeaf):\n        return next(xs)\n    else:\n        children = safe_map(partial(_tree_unflatten, xs), treedef.children)\n        return treedef.node_type.from_iterable(treedef.node_data, children)\ndef _num_leaves(treedef):\n    return 1 if isinstance(treedef, PyLeaf) else sum(safe_map(_num_leaves, treedef.children))\ndef _nested_treedef(inner, outer):"
        },
        {
            "comment": "The code defines a `PyTreeDef` class representing nodes in a tree structure. It checks if the input is a leaf node, then creates children objects using `_nested_treedef` and `safe_map`, and returns an instance of `PyTreeDef` with the given node type, data, and children. The class also provides a custom `__repr__` method for string representation, a `__hash__` method for hashability, and an `__eq__` method for equality comparison.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":171-200",
            "content": "    # just used in tree_transpose error checking\n    if isinstance(outer, PyLeaf):\n        return inner\n    else:\n        children = safe_map(partial(_nested_treedef, inner), outer.children)\n        return PyTreeDef(outer.node_type, outer.node_data, tuple(children))\nclass PyTreeDef(object):\n    def __init__(self, node_type, node_data, children):\n        self.node_type = node_type\n        self.node_data = node_data\n        self.children = children\n    def __repr__(self):\n        if self.node_data is None:\n            data_repr = \"\"\n        else:\n            data_repr = \"[{}]\".format(self.node_data)\n        return \"PyTree({}{}, [{}])\".format(self.node_type.name, data_repr, \",\".join(safe_map(repr, self.children)))\n    def __hash__(self):\n        return hash((self.node_type, self.node_data, tuple(self.children)))\n    def __eq__(self, other):\n        if isinstance(other, PyLeaf):\n            return False\n        else:\n            return self.node_type == other.node_type and self.node_data == other.node_data and self.children == other.children"
        },
        {
            "comment": "This code defines a class hierarchy for representing and serializing objects in a tree-like structure. It includes methods for converting different types of collections (tuples, lists, dictionaries) to iterable and back. The `NodeType` class stores information about the type and its conversion rules, which are registered using the `register_pytree_node` function.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":202-255",
            "content": "    def __ne__(self, other):\n        return not self == other\nclass PyLeaf(object):\n    def __repr__(self):\n        return \"*\"\n    def __eq__(self, other):\n        return isinstance(other, PyLeaf)\nclass NodeType(object):\n    def __init__(self, name, to_iterable, from_iterable):\n        self.name = name\n        self.to_iterable = to_iterable\n        self.from_iterable = from_iterable\nnode_types: Dict[type, NodeType] = {}\ndef register_pytree_node(py_type, to_iterable, from_iterable):\n    assert py_type not in node_types\n    node_types[py_type] = NodeType(str(py_type), to_iterable, from_iterable)\ndef tuple_to_iterable(xs):\n    return xs, None\ndef tuple_from_iterable(_keys, xs):\n    return tuple(xs)\ndef list_to_iterable(xs):\n    return tuple(xs), None\ndef list_from_iterable(_keys, xs):\n    return list(xs)\ndef dict_to_iterable(xs):\n    keys = tuple(sorted(xs.keys()))\n    return tuple(map(xs.get, keys)), keys\ndef dict_from_iterable(keys, xs):\n    return dict(safe_zip(keys, xs))\ndef ordered_dict_from_iterable(keys, xs):\n    return collections.OrderedDict(safe_zip(keys, xs))"
        },
        {
            "comment": "This code registers different data types and their conversion functions for serialization using the PyTree API. It handles tuples, lists, dictionaries (including OrderedDict), collections.defaultdict, and None type. The default_dict_to_iterable, default_dict_from_iterable, none_to_iterable, and none_from_iterable functions handle the conversion to and from iterables for these data types.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/tree_util.py\":258-279",
            "content": "def default_dict_to_iterable(xs):\n    return (tuple(xs.values()), (xs.default_factory, tuple(xs.keys())))\ndef default_dict_from_iterable(keys, xs):\n    return collections.defaultdict(keys[0], safe_zip(keys[1], xs))\ndef none_to_iterable(_xs):\n    return (), None\ndef none_from_iterable(_keys, _xs):\n    return None\nregister_pytree_node(tuple, tuple_to_iterable, tuple_from_iterable)\nregister_pytree_node(list, list_to_iterable, list_from_iterable)\nregister_pytree_node(dict, dict_to_iterable, dict_from_iterable)\nregister_pytree_node(collections.OrderedDict, dict_to_iterable, ordered_dict_from_iterable)\nregister_pytree_node(collections.defaultdict, default_dict_to_iterable, default_dict_from_iterable)\nregister_pytree_node(type(None), none_to_iterable, none_from_iterable)"
        }
    ]
}