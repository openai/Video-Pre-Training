{
    "summary": "Both comments discuss data processing tasks, with Comment A focusing on calculating and dividing products in a list 'x', while Comment B describes a function for reshaping input data, considering exceptions and undo functions, and utilizing a 'known' dictionary for shape inference.",
    "details": [
        {
            "comment": "The code contains several functions related to data manipulation, such as calculating the product of a sequence of integers (`intprod`), checking and zipping lengths of sequences (`safezip`), transposing data with given before and after specifications (`transpose`), and undoing a data transposition (`transpose_undo`).",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":0-42",
            "content": "import numpy as np\nimport torch as th\ndef intprod(xs):\n    \"\"\"\n    Product of a sequence of integers\n    \"\"\"\n    out = 1\n    for x in xs:\n        out *= x\n    return out\ndef safezip(*args):\n    \"\"\"\n    Check that lengths of sequences are the same, then zip them\n    \"\"\"\n    args = [list(a) for a in args]\n    n = len(args[0])\n    for arg in args[1:]:\n        assert len(arg) == n, f\"length mismatch: {list(map(len, args))}\"\n    return list(zip(*args))\ndef transpose(x, before, after):\n    \"\"\"\n    Usage: x_bca = transpose(x_abc, 'abc', 'bca')\n    \"\"\"\n    assert sorted(before) == sorted(after), f\"cannot transpose {before} to {after}\"\n    assert x.ndim == len(\n        before\n    ), f\"before spec '{before}' has length {len(before)} but x has {x.ndim} dimensions: {tuple(x.shape)}\"\n    return x.permute(tuple(before.index(i) for i in after))\ndef transpose_undo(x, before, after, *, undo=None):\n    \"\"\"\n    Usage:\n    x_bca, undo = transpose_undo(x_abc, 'abc', 'bca')\n    x_bca = fully_connected_layer(x_bca)\n    x_abc = undo(x_bca)\n    \"\"\""
        },
        {
            "comment": "Function `transpose` takes an input tensor, and a list of tuples specifying the axes to permute. It returns the transposed tensor and a function that undoes the transpose operation.\nFunction `compose_undo` combines two transformation functions into a single one that applies them in reverse order. If either is None, it simply returns the other. Otherwise, it creates an anonymous function that first applies the second transformation, then the first, and finally returns the result.\nString `NO_BIND` is used as a placeholder when a dimension cannot be bound to a specific variable.\nFunction `_parse_reshape_str` parses a string of the form \"x,*y,?z\" where x, y, and z are integers or '?' symbols. It returns a list containing three lists: the first contains '?' characters for 'before', '_' characters for 'after', and actual numbers for 'none'. The second contains actual numbers for 'before', and the third contains actual numbers for 'after'.\nFunction `_infer_part` infers the part of the tensor shape to be used based on the type of the input. If it is an integer, it returns that integer. Otherwise, it processes a list of terms, handling integers and strings containing '*' symbols differently.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":43-88",
            "content": "    return (\n        transpose(x, before, after),\n        compose_undo(undo, lambda x: transpose(x, before=after, after=before)),\n    )\ndef compose_undo(u1, u2):\n    assert u2 is not None\n    if u1 is None:\n        return u2\n    def u(x):\n        x = u2(x)\n        x = u1(x)\n        return x\n    return u\nNO_BIND = \"__nobind\"\ndef _parse_reshape_str(s, kind):\n    assert kind in (\"before\", \"after\")\n    result = []\n    n_underscores = 0\n    for i, part in enumerate(s.split(\",\")):\n        part = part.strip()\n        if part == \"?\" and kind == \"before\":\n            result.append([f\"__{i}\"])\n        elif part == \"_\":\n            result.append([f\"{NO_BIND}_{n_underscores}\"])\n            n_underscores += 1\n        else:\n            result.append([term.strip() for term in part.split(\"*\")])\n    return result\ndef _infer_part(part, concrete_dim, known, index, full_shape):\n    if type(part) is int:\n        return part\n    assert isinstance(part, list), part\n    lits = []\n    syms = []\n    for term in part:\n        if type(term) is int:"
        },
        {
            "comment": "This function takes a term, checks if it's an int or str, and performs calculations based on the input type. If int, it multiplies all literals (int or float) and returns the result. If str, it checks if there's only one symbol and concrete_dim is given. It asserts that concrete_dim is divisible by int_part and calculates v. If the symbol is already in known values, it asserts the known value matches. If not, it adds the symbol to known with its calculated value. Finally, if there are multiple symbols, it iterates through them and converts strings to ints.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":89-117",
            "content": "            lits.append(term)\n        elif type(term) is str:\n            syms.append(term)\n        else:\n            raise TypeError(f\"got {type(term)} but expected int or str\")\n    int_part = 1\n    for x in lits:\n        int_part *= x\n    if len(syms) == 0:\n        return int_part\n    elif len(syms) == 1 and concrete_dim is not None:\n        assert concrete_dim % int_part == 0, f\"{concrete_dim} % {int_part} != 0 (at index {index}, full shape is {full_shape})\"\n        v = concrete_dim // int_part\n        if syms[0] in known:\n            assert (\n                known[syms[0]] == v\n            ), f\"known value for {syms[0]} is {known[syms[0]]} but found value {v} at index {index} (full shape is {full_shape})\"\n        else:\n            known[syms[0]] = v\n        return concrete_dim\n    else:\n        for i in range(len(syms)):\n            if syms[i] in known:\n                syms[i] = known[syms[i]]\n            else:\n                try:\n                    syms[i] = int(syms[i])\n                except ValueError:\n                    pass"
        },
        {
            "comment": "This function takes an existing list `lits` and a symbol `syms` and returns a new list where the `syms` occur after all elements in `lits`. The `_infer_step()` function takes known values, description, and shape as arguments. It creates copies of the new known and description lists and loops through each element in the description list. If a specific shape is provided, it assigns the corresponding dimension to `concrete_dim`. Then, it calls `_infer_part()` with the part, concrete dimension, known values, index, and full shape as arguments. The function returns the new known values, description list, and shape. The `fixed_point()` function uses a lambda function to check for equality between two inputs. It continues to apply the given function to the input until it reaches a fixed point where the input remains unchanged. Lastly, `_infer_question_mark()` function tries to find the index of \"?\" in the list and returns the list if found.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":118-156",
            "content": "        return lits + syms\ndef _infer_step(args):\n    known, desc, shape = args\n    new_known = known.copy()\n    new_desc = desc.copy()\n    for i in range(len(desc)):\n        if shape is None:\n            concrete_dim = None\n        else:\n            concrete_dim = shape[i]\n        new_desc[i] = _infer_part(part=desc[i], concrete_dim=concrete_dim, known=new_known, index=i, full_shape=shape)\n    return new_known, new_desc, shape\ndef _infer(known, desc, shape):\n    if shape is not None:\n        assert len(desc) == len(shape), f\"desc has length {len(desc)} but shape has length {len(shape)} (shape={shape})\"\n    known, desc, shape = fixed_point(_infer_step, (known, desc, shape))\n    return desc, known\ndef fixed_point(f, x, eq=None):\n    if eq is None:\n        eq = lambda a, b: a == b\n    while True:\n        new_x = f(x)\n        if eq(x, new_x):\n            return x\n        else:\n            x = new_x\ndef _infer_question_mark(x, total_product):\n    try:\n        question_mark_index = x.index([\"?\"])\n    except ValueError:\n        return x"
        },
        {
            "comment": "- Calculate product of known values in list 'x'\n- Assert that the total product is divisible by observed product and return error message if not\n- Update list 'x' with calculated value for the question mark index and return it",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":157-186",
            "content": "    observed_product = 1\n    for i in range(len(x)):\n        if i != question_mark_index:\n            assert type(x[i]) is int, f\"when there is a question mark, there can be no other unknown values (full list: {x})\"\n            observed_product *= x[i]\n    assert (\n        observed_product and total_product % observed_product == 0\n    ), f\"{total_product} is not divisible by {observed_product}\"\n    value = total_product // observed_product\n    x = x.copy()\n    x[question_mark_index] = value\n    return x\ndef _ground(x, known, infer_question_mark_with=None):\n    x, known = _infer(known=known, desc=x, shape=None)\n    if infer_question_mark_with:\n        x = _infer_question_mark(x, infer_question_mark_with)\n    for part in x:\n        assert type(part) is int, f\"cannot infer value of {part}\"\n    return x\ndef _handle_ellipsis(x, before, after):\n    ell = [\"...\"]\n    try:\n        i = before.index(ell)\n        l = len(x.shape) - len(before) + 1\n        ellipsis_value = x.shape[i : i + l]\n        ellipsis_value = list(ellipsis_value)"
        },
        {
            "comment": "The code performs shape reshaping operations and handles any exceptions that may occur during the process. It takes input, initial 'before' and 'after' shapes as arguments, and optional 'undo' and 'known' parameters. If 'known' is provided, it becomes a dictionary of known values to help with shape inference. The function returns reshaped input and an 'undo' function for reverting the reshape operation.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":187-222",
            "content": "        before = before[:i] + ellipsis_value + before[i + 1 :]\n    except ValueError:\n        pass\n    try:\n        i = after.index(ell)\n        after = after[:i] + ellipsis_value + after[i + 1 :]\n    except ValueError:\n        pass\n    except UnboundLocalError as e:\n        raise ValueError(\"there cannot be an ellipsis in 'after' unless there is an ellipsis in 'before'\") from e\n    return before, after\ndef reshape_undo(inp, before, after, *, undo=None, known=None, **kwargs):\n    \"\"\"\n    Usage:\n    x_Bhwse, undo = reshape_undo(\n        x_bthwe,\n        'b, t, ..., stride*e',\n        'b*t, ..., stride, e',\n        stride=7\n    )\n    x_Bhwse = do_some_stuff(x_Bhwse)\n    x_bthwe = undo(x_Bhwse)\n    It's necessary to pass known values as keywords only\n    when they can't be inferred from the shape.\n    (Eg. in the above example we needed to pass\n    stride but not b, t, or e, since those can be determined from\n    inp.shape once stride is known.)\n    \"\"\"\n    if known:\n        known = {**kwargs, **known}\n    else:\n        known = kwargs"
        },
        {
            "comment": "Ensures input types are correct and parses reshape string if input is a string. Infers the shape of the input, grounds it, and removes any bindings marked with NO_BIND. Asserts that the shapes match and returns the result.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":223-239",
            "content": "    assert type(before) is type(after), f\"{type(before)} != {type(after)}\"\n    assert isinstance(inp, (th.Tensor, np.ndarray)), f\"require tensor or ndarray but got {type(inp)}\"\n    assert isinstance(before, (str, list)), f\"require str or list but got {type(before)}\"\n    if isinstance(before, str):\n        before = _parse_reshape_str(before, \"before\")\n        after = _parse_reshape_str(after, \"after\")\n        before, after = _handle_ellipsis(inp, before, after)\n    before_saved, after_saved = before, after\n    before, known = _infer(known=known, desc=before, shape=inp.shape)\n    before = _ground(before, known, product(inp.shape))\n    after = _ground(after, known, product(inp.shape))\n    known = {k: v for k, v in known.items() if not k.startswith(NO_BIND)}\n    assert tuple(inp.shape) == tuple(before), f\"expected shape {before} but got shape {inp.shape}\"\n    assert product(inp.shape) == product(\n        after\n    ), f\"cannot reshape {inp.shape} to {after} because the number of elements does not match\"\n    return ("
        },
        {
            "comment": "The code contains functions for reshaping arrays, calculating products of a list of numbers, and performing an exact division.",
            "location": "\"/media/root/Toshiba XG3/works/Video-Pre-Training/docs/src/lib/misc.py\":240-262",
            "content": "        inp.reshape(after),\n        compose_undo(undo, lambda inp: reshape(inp, after_saved, before_saved, known=known)),\n    )\ndef reshape(*args, **kwargs):\n    \"\"\"\n    Please see the documenation for reshape_undo.\n    \"\"\"\n    x, _ = reshape_undo(*args, **kwargs)\n    return x\ndef product(xs, one=1):\n    result = one\n    for x in xs:\n        result = result * x\n    return result\ndef exact_div(a, b):\n    assert a % b == 0, f\"{a} is not divisible by {b}\"\n    return a // b"
        }
    ]
}